<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数字テトリス</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .game-container {
            touch-action: manipulation;
        }
        .block {
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-sizing: border-box;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
            transition: all 0.1s ease;
        }
        .controls button {
            touch-action: manipulation;
        }
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .flash {
            animation: flash 0.3s 2;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <div class="text-center mb-4">
        <h1 class="text-3xl font-bold mb-2">数字テトリス</h1>
        <p class="text-gray-300 mb-4">隣り合う数字の合計が10になると消えます</p>
        <div class="flex justify-between w-full max-w-md mx-auto mb-4">
            <div class="text-left">
                <p>スコア: <span id="score">0</span></p>
                <p>レベル: <span id="level">1</span></p>
            </div>
            <div class="text-right">
                <p>次のミノ:</p>
                <div id="next-piece" class="inline-block"></div>
            </div>
        </div>
    </div>

    <div class="relative game-container bg-gray-800 border-2 border-gray-700 mb-4" id="game-board"></div>

    <div class="controls flex flex-col items-center w-full max-w-md">
        <div class="grid grid-cols-3 gap-2 mb-4 w-full">
            <button id="left" class="bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg">←</button>
            <button id="rotate" class="bg-purple-600 hover:bg-purple-700 text-white py-3 rounded-lg">回転</button>
            <button id="right" class="bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg">→</button>
        </div>
        <div class="w-full">
            <button id="down" class="bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg w-full mb-2">↓ 速く落下</button>
            <button id="drop" class="bg-red-600 hover:bg-red-700 text-white py-3 rounded-lg w-full">一気に落下</button>
        </div>
    </div>

    <div id="game-over" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg text-center max-w-md w-full">
            <h2 class="text-2xl font-bold mb-4">ゲームオーバー</h2>
            <p class="mb-4">最終スコア: <span id="final-score">0</span></p>
            <button id="restart" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-6 rounded-lg">もう一度遊ぶ</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 30;
            const COLORS = [
                '#FF5252', '#FF4081', '#E040FB', '#7C4DFF',
                '#536DFE', '#448AFF', '#40C4FF', '#18FFFF',
                '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41',
                '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
            ];

            let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            let currentPiece = null;
            let nextPiece = null;
            let score = 0;
            let level = 1;
            let gameOver = false;
            let dropInterval = 1000;
            let lastDrop = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            let isProcessing = false;

            const gameBoard = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const nextPieceElement = document.getElementById('next-piece');
            const gameOverElement = document.getElementById('game-over');
            const finalScoreElement = document.getElementById('final-score');

            gameBoard.style.width = `${COLS * BLOCK_SIZE}px`;
            gameBoard.style.height = `${ROWS * BLOCK_SIZE}px`;

            const PIECES = [
                { shape: [[1, 1, 1, 1]], numbers: [1, 2, 3, 4], name: 'I' },
                { shape: [[1, 1], [1, 1]], numbers: [5, 6, 7, 8], name: 'O' },
                { shape: [[0, 1, 0], [1, 1, 1]], numbers: [9, 0, 1, 2], name: 'T' },
                { shape: [[1, 1, 0], [0, 1, 1]], numbers: [3, 4, 5, 6], name: 'S' },
                { shape: [[0, 1, 1], [1, 1, 0]], numbers: [7, 8, 9, 0], name: 'Z' },
                { shape: [[1, 0, 0], [1, 1, 1]], numbers: [1, 2, 3, 4], name: 'L' },
                { shape: [[0, 0, 1], [1, 1, 1]], numbers: [5, 6, 7, 8], name: 'J' }
            ];

            function init() {
                board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                score = 0;
                level = 1;
                gameOver = false;
                isProcessing = false;
                dropInterval = 1000;
                updateScore();
                generatePiece();
                drawBoard();
                lastDrop = Date.now();
                gameOverElement.classList.add('hidden');
                requestAnimationFrame(gameLoop);
            }

            function gameLoop(timestamp) {
                if (gameOver) return;

                const now = Date.now();
                const delta = now - lastDrop;

                if (delta > dropInterval && !isProcessing) {
                    moveDown();
                    lastDrop = now;
                }

                drawBoard();
                requestAnimationFrame(gameLoop);
            }

            function generatePiece() {
                if (!nextPiece) {
                    nextPiece = getRandomPiece();
                }

                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                drawNextPiece();

                if (collision(0, 0)) {
                    gameOver = true;
                    finalScoreElement.textContent = score;
                    gameOverElement.classList.remove('hidden');
                }
            }

            function getRandomPiece() {
                const randomIndex = Math.floor(Math.random() * PIECES.length);
                const piece = PIECES[randomIndex];
                const numbers = [...piece.numbers].map(num => Number(num) % 10);

                return {
                    shape: JSON.parse(JSON.stringify(piece.shape)),
                    numbers: numbers,
                    x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                    y: 0,
                    name: piece.name
                };
            }

            function collision(offsetX, offsetY, newShape = null) {
                const shape = newShape || currentPiece.shape;

                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const newX = currentPiece.x + x + offsetX;
                            const newY = currentPiece.y + y + offsetY;

                            if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && board[newY][newX])) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            function rotateNumbers(numbers, originalShape, newShape) {
                const mapping = [];
                let numIndex = 0;

                for (let y = 0; y < originalShape.length; y++) {
                    for (let x = 0; x < originalShape[y].length; x++) {
                        if (originalShape[y][x]) {
                            mapping.push({ origX: x, origY: y, num: numbers[numIndex++] });
                        }
                    }
                }

                const newRows = newShape.length;
                const newCols = newShape[0].length;
                const rotatedGrid = Array(newRows).fill().map(() => Array(newCols).fill(null));

                mapping.forEach(item => {
                    const newX = originalShape.length - 1 - item.origY;
                    const newY = item.origX;
                    if (newY < newRows && newX < newCols) {
                        rotatedGrid[newY][newX] = item.num;
                    }
                });

                const result = [];
                for (let y = 0; y < newRows; y++) {
                    for (let x = 0; x < newCols; x++) {
                        if (newShape[y][x] && rotatedGrid[y][x] !== null) {
                            result.push(rotatedGrid[y][x]);
                        }
                    }
                }

                return result;
            }

            function lockPiece() {
                if (isProcessing) return;
                isProcessing = true;

                let numIndex = 0;
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            const boardY = currentPiece.y + y;
                            const boardX = currentPiece.x + x;

                            if (boardY >= 0) {
                                const num = currentPiece.numbers[numIndex++] % 10;
                                board[boardY][boardX] = {
                                    color: COLORS[num],
                                    number: num
                                };
                            }
                        }
                    }
                }

                checkFullRows();
                setTimeout(() => {
                    checkMatches();
                }, 50);
            }

            function checkFullRows() {
                let rowsToClear = [];

                for (let y = ROWS - 1; y >= 0; y--) {
                    let rowFull = true;
                    for (let x = 0; x < COLS; x++) {
                        if (!board[y][x]) {
                            rowFull = false;
                            break;
                        }
                    }
                    if (rowFull) rowsToClear.push(y);
                }

                if (rowsToClear.length > 0) {
                    for (const row of rowsToClear) {
                        for (let x = 0; x < COLS; x++) {
                            board[row][x] = 0;
                        }
                    }

                    const linePoints = [0, 100, 300, 500, 800];
                    score += linePoints[rowsToClear.length] * level;
                    updateScore();

                    dropBlocks();
                }
            }

            function checkMatches() {
                const directions = [
                    { dx: 1, dy: 0 },
                    { dx: 0, dy: 1 }
                ];

                let matchedBlocks = new Set();
                let hasMatches = false;

                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const currentNum = board[y][x].number;

                            for (const dir of directions) {
                                const nx = x + dir.dx;
                                const ny = y + dir.dy;

                                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && board[ny][nx]) {
                                    const neighborNum = board[ny][nx].number;

                                    if ((currentNum + neighborNum) === 10) {
                                        matchedBlocks.add(`${x},${y}`);
                                        matchedBlocks.add(`${nx},${ny}`);
                                        hasMatches = true;
                                    }
                                }
                            }
                        }
                    }
                }

                if (hasMatches) {
                    const blocks = Array.from(matchedBlocks).map(key => {
                        const [x, y] = key.split(',').map(Number);
                        return { x, y };
                    });

                    for (const block of blocks) {
                        board[block.y][block.x] = 0;
                    }

                    score += blocks.length * 10 * level;
                    updateScore();

                    dropBlocks();

                    setTimeout(() => {
                        checkMatches();
                    }, 100);
                } else {
                    isProcessing = false;
                    generatePiece();
                }
            }

            function dropBlocks() {
                for (let x = 0; x < COLS; x++) {
                    let writePos = ROWS - 1;

                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (board[y][x]) {
                            if (y !== writePos) {
                                board[writePos][x] = board[y][x];
                                board[y][x] = 0;
                            }
                            writePos--;
                        }
                    }
                }
            }

            function movePiece(offsetX, offsetY) {
                if (gameOver || isProcessing) return false;

                if (!collision(offsetX, offsetY)) {
                    currentPiece.x += offsetX;
                    currentPiece.y += offsetY;
                    return true;
                }
                return false;
            }

            function rotatePiece() {
                if (gameOver || isProcessing) return;

                const originalShape = currentPiece.shape;
                const rows = originalShape.length;
                const cols = originalShape[0].length;

                if (currentPiece.name === 'O') return;

                const newShape = Array(cols).fill().map(() => Array(rows).fill(0));

                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (originalShape[y][x]) {
                            newShape[x][rows - 1 - y] = 1;
                        }
                    }
                }

                const newNumbers = rotateNumbers(currentPiece.numbers, originalShape, newShape);

                if (!collision(0, 0, newShape)) {
                    currentPiece.shape = newShape;
                    currentPiece.numbers = newNumbers;

                    if (currentPiece.x < 0) currentPiece.x = 0;
                    if (currentPiece.x + newShape[0].length > COLS) {
                        currentPiece.x = COLS - newShape[0].length;
                    }
                }
            }

            function moveDown() {
                if (!movePiece(0, 1)) {
                    lockPiece();
                }
            }

            function hardDrop() {
                if (gameOver || isProcessing) return;
                while (movePiece(0, 1)) {}
                lockPiece();
            }

            function drawBoard() {
                gameBoard.innerHTML = '';

                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const block = document.createElement('div');
                            block.className = 'block';
                            block.style.width = `${BLOCK_SIZE}px`;
                            block.style.height = `${BLOCK_SIZE}px`;
                            block.style.left = `${x * BLOCK_SIZE}px`;
                            block.style.top = `${y * BLOCK_SIZE}px`;
                            block.style.backgroundColor = board[y][x].color;
                            block.textContent = board[y][x].number;
                            gameBoard.appendChild(block);
                        }
                    }
                }

                if (currentPiece && !isProcessing) {
                    let numIndex = 0;
                    for (let y = 0; y < currentPiece.shape.length; y++) {
                        for (let x = 0; x < currentPiece.shape[y].length; x++) {
                            if (currentPiece.shape[y][x]) {
                                const blockY = currentPiece.y + y;
                                const blockX = currentPiece.x + x;

                                if (blockY >= 0) {
                                    const num = currentPiece.numbers[numIndex++] % 10;

                                    const block = document.createElement('div');
                                    block.className = 'block';
                                    block.style.width = `${BLOCK_SIZE}px`;
                                    block.style.height = `${BLOCK_SIZE}px`;
                                    block.style.left = `${blockX * BLOCK_SIZE}px`;
                                    block.style.top = `${blockY * BLOCK_SIZE}px`;
                                    block.style.backgroundColor = COLORS[num];
                                    block.style.opacity = '0.8';
                                    block.textContent = num;
                                    gameBoard.appendChild(block);
                                }
                            }
                        }
                    }
                }
            }

            function drawNextPiece() {
                nextPieceElement.innerHTML = '';

                if (nextPiece) {
                    const container = document.createElement('div');
                    container.style.width = `${nextPiece.shape[0].length * BLOCK_SIZE / 2}px`;
                    container.style.height = `${nextPiece.shape.length * BLOCK_SIZE / 2}px`;
                    container.style.position = 'relative';

                    let numIndex = 0;
                    for (let y = 0; y < nextPiece.shape.length; y++) {
                        for (let x = 0; x < nextPiece.shape[y].length; x++) {
                            if (nextPiece.shape[y][x]) {
                                const num = nextPiece.numbers[numIndex++] % 10;

                                const block = document.createElement('div');
                                block.className = 'block';
                                block.style.width = `${BLOCK_SIZE / 2}px`;
                                block.style.height = `${BLOCK_SIZE / 2}px`;
                                block.style.left = `${x * BLOCK_SIZE / 2}px`;
                                block.style.top = `${y * BLOCK_SIZE / 2}px`;
                                block.style.backgroundColor = COLORS[num];
                                block.style.fontSize = '0.7rem';
                                block.textContent = num;
                                container.appendChild(block);
                            }
                        }
                    }

                    nextPieceElement.appendChild(container);
                }
            }

            function updateScore() {
                scoreElement.textContent = score;
                levelElement.textContent = level;
                const newLevel = Math.floor(score / 500) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
                }
            }

            document.getElementById('left').addEventListener('click', () => movePiece(-1, 0));
            document.getElementById('right').addEventListener('click', () => movePiece(1, 0));
            document.getElementById('down').addEventListener('click', () => moveDown());
            document.getElementById('rotate').addEventListener('click', () => rotatePiece());
            document.getElementById('drop').addEventListener('click', () => hardDrop());
            document.getElementById('restart').addEventListener('click', () => init());

            document.addEventListener('keydown', (e) => {
                if (gameOver || isProcessing) return;

                switch (e.key) {
                    case 'ArrowLeft': movePiece(-1, 0); break;
                    case 'ArrowRight': movePiece(1, 0); break;
                    case 'ArrowDown': moveDown(); break;
                    case 'ArrowUp': rotatePiece(); break;
                    case ' ': e.preventDefault(); hardDrop(); break;
                }
            });

            gameBoard.addEventListener('touchstart', (e) => {
                if (gameOver || isProcessing) return;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                e.preventDefault();
            }, { passive: false });

            gameBoard.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });

            gameBoard.addEventListener('touchend', (e) => {
                if (gameOver || isProcessing) return;

                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const threshold = 30;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > threshold) {
                        movePiece(1, 0);
                    } else if (diffX < -threshold) {
                        movePiece(-1, 0);
                    }
                } else {
                    if (diffY > threshold) {
                        hardDrop();
                    } else if (diffY < -threshold) {
                        rotatePiece();
                    } else {
                        moveDown();
                    }
                }

                e.preventDefault();
            }, { passive: false });

            init();
        });
    </script>
</body>
</html>
